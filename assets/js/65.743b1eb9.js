(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{427:function(e,t,r){"use strict";r.r(t);var s=r(7),v=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"kubenetes-k8s"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubenetes-k8s"}},[e._v("#")]),e._v(" Kubenetes(k8s)")]),e._v(" "),t("h2",{attrs:{id:"_1-什么是kubenetes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是kubenetes"}},[e._v("#")]),e._v(" 1.什么是Kubenetes")]),e._v(" "),t("p",[e._v("Kubenetes是Google开源的容器集群管理系统，主要负责容器编排。它支持自动化部署，大规模可伸缩，应用容器化管理。在生产环境部署一个应用程序时，通常要部署该应用的多个实例以便应用请求负载均衡。在Kubenetes中，这些实例被抽象为容器。每个容器里面运行一个应用实例。然后通过内置的负载均衡策略，实现对这已组应用的管理，发现，访问，而这些细节不需要运维人员去进行复杂的手工配置和处理。")]),e._v(" "),t("h2",{attrs:{id:"_2-核心概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-核心概念"}},[e._v("#")]),e._v(" 2.核心概念")]),e._v(" "),t("h3",{attrs:{id:"node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[e._v("#")]),e._v(" Node")]),e._v(" "),t("p",[e._v("Node是Kubenetes集群中的工作节点，可以是物理机也可以是虚拟机。\n用于托管正在运营的应用，可以虚拟机或物理机，它是在集群中充当工作机器的角色，每个Node都有Kubelet，它管理Node而且是Node与Master通信的代理，Node还具有用于处理容器操作的工具，例如Docker或rkt。")]),e._v(" "),t("p",[e._v("Master是Kubenetes集群的调度器，它负责管理整个集群。\n协调集群中所有活动，例如调用应用，维护应用的所需状态，应用扩容以及推出新的更新。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/qouson/my-pic-bed/pic/202406191115649.png",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"pod"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pod"}},[e._v("#")]),e._v(" Pod")]),e._v(" "),t("p",[e._v("Pod相当于逻辑主机的概念，负责托管应用实例。包括一个或多个应用程序容器，以及这些容器的一些共享资源（共享存储，网络，运行信息等。）")]),e._v(" "),t("p",[e._v("Pod是Kubenetes的最小工作单元，每个Pod包含一个或多个容器。\nPod中的容器共享网络和存储，它们之间可以通过localhost进行通信。\nPod中的容器可以共享资源，例如CPU和内存。\nPod中的容器可以共享存储，例如Docker卷。\nPod中的容器可以协调和同步，例如Docker容器的生命周期。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/qouson/my-pic-bed/pic/202406191116612.png",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"deploymnet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#deploymnet"}},[e._v("#")]),e._v(" Deploymnet")]),e._v(" "),t("p",[e._v("负责创建和更新应用程序的实例。创建Deployment后，Kubenetes Master将应用程序实例调度到集群的各个节点上。如果托管实例的节点关闭或被删除，Deployment控制器会将该实例替换为集群中例已个节点上的实例，这提供了一种自我修复机制来解决机器故障维护问题。")]),e._v(" "),t("p",[e._v("本身之上是Pod控制器，配置一组Pod，k8s不会直接控制Pod，而是操作Deployment")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/qouson/my-pic-bed/pic/202406191121287.png",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"service"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service"}},[e._v("#")]),e._v(" Service")]),e._v(" "),t("p",[e._v("Service是一个抽象层，它定义了一组Pod逻辑集合，并为这些Pod支持外部流量暴露，负载均衡和服务发现。")]),e._v(" "),t("p",[e._v("尽管每个Pod都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在集群外部。Service允许你的应用接收流量。Service也可以用在ServiceSpec标记为type的方式暴露，type类型如下：")]),e._v(" "),t("ul",[t("li",[e._v("ClusterIP（默认）：在集群的内部IP上公开Service，这种类型使得Service只能从集群访问")]),e._v(" "),t("li",[e._v("NodePort：使用NAT在集群中每个选定的Node的相同端口上公开Service。使用"),t("NodeIP",[e._v(":"),t("NodePort",[e._v("从集群外部访问Service。是ClusterIP的超集。")])],1)],1),e._v(" "),t("li",[e._v("LoadBalancer：在当前云中创建一个外部负载均衡器（如果支持的话），并为Service分配一个固定的外部IP。是NodePort的超集。")]),e._v(" "),t("li",[e._v("ExternelName：通过返回带有名称的CNAME记录，使用任意名称（由spec中的externalName指定）公开Service。不使用代理。")])]),e._v(" "),t("h3",{attrs:{id:"service和deployment区别与联系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service和deployment区别与联系"}},[e._v("#")]),e._v(" Service和Deployment区别与联系")]),e._v(" "),t("p",[e._v("参考\nhttps://blog.csdn.net/HiWangWenBing/article/details/122798876")]),e._v(" "),t("h2",{attrs:{id:"_3-kubenetes组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-kubenetes组件"}},[e._v("#")]),e._v(" 3.Kubenetes组件")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/qouson/my-pic-bed/pic/202406191129264.png",alt:""}})]),e._v(" "),t("h2",{attrs:{id:"控制平面组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制平面组件"}},[e._v("#")]),e._v(" 控制平面组件")]),e._v(" "),t("ul",[t("li",[e._v("1.API server\n"),t("ul",[t("li",[e._v("资源操作的唯一入口，接收用户输入的命令，提供认证，授权，API注册和发现机制")])])]),e._v(" "),t("li",[e._v("2.Etcd\n"),t("ul",[t("li",[e._v("负责存储集群中各种资源对象的信息")])])]),e._v(" "),t("li",[e._v("3.Scheduler\n"),t("ul",[t("li",[e._v("负责集群资源调度，按照预定的调度策略将Pod调度到相应的Node节点上")])])]),e._v(" "),t("li",[e._v("4.Controller manager\n"),t("ul",[t("li",[e._v("负责维护集群的状态，比如程序部署安排，故障检测，自动扩展，滚动更新（部署和维护）")])])])]),e._v(" "),t("h2",{attrs:{id:"节点组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#节点组件"}},[e._v("#")]),e._v(" 节点组件")]),e._v(" "),t("ul",[t("li",[e._v("1.kubelet\n"),t("ul",[t("li",[e._v("负责维护容器的生命周期，即通过控制docker，来创建更新，销毁容器")])])]),e._v(" "),t("li",[e._v("2.kube-proxy\n"),t("ul",[t("li",[e._v("负责提供集群内部服务发现和负载均衡")])])]),e._v(" "),t("li",[e._v("3.Docker（Container runtime）\n"),t("ul",[t("li",[e._v("负责节点上容器的各种操作")])])])])])}),[],!1,null,null,null);t.default=v.exports}}]);