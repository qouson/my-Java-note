(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{394:function(a,t,s){"use strict";s.r(t);var v=s(7),r=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[a._v("#")]),a._v(" 集合")]),a._v(" "),t("h2",{attrs:{id:"hasmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hasmap"}},[a._v("#")]),a._v(" HasMap")]),a._v(" "),t("h3",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),t("h4",{attrs:{id:"jdk1-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-7"}},[a._v("#")]),a._v(" JDK1.7")]),a._v(" "),t("ul",[t("li",[a._v("数组+链表")]),a._v(" "),t("li",[a._v("使用头插法")])]),a._v(" "),t("h4",{attrs:{id:"jdk1-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8"}},[a._v("#")]),a._v(" JDK1.8")]),a._v(" "),t("ul",[t("li",[a._v("数组 + 链表 + 红黑树")]),a._v(" "),t("li",[a._v("使用尾插法")])]),a._v(" "),t("h3",{attrs:{id:"put方法流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#put方法流程"}},[a._v("#")]),a._v(" put方法流程")]),a._v(" "),t("ul",[t("li",[a._v("hash/扰动函数，(key == null) ? 0 : (h = key.\nhashCode()) ^ (h >>> 16)，高16不动，高16位异或低16位，增加结果随机性\n"),t("ul",[t("li",[a._v("扰动函数解析：用于计算一个改进后的哈希码，主要用于提高哈希码的分布质量")]),a._v(" "),t("li",[a._v("获取哈希吗：key.hashCode()，int取值[-2147483648,2147483647]，获取对象key的哈希码，并赋值给h")]),a._v(" "),t("li",[a._v("无符号右移：(h >>> 16) 表示将h的二进制表示无符号右移16位。这意味着h的最高有效16位被移除，最低有效位补入16个0。此操作让原来在高位的信息移到了低位")]),a._v(" "),t("li",[a._v("异或操作：^是按位异或操作符。当你对两个数进行异或操作时，如果两位相同结果为0，如果两位不同结果为1。通过h和右移后的h进行异或，可以将原来本高位信息与低位信息混合。")])])]),a._v(" "),t("li",[a._v("将扰动后的值与length - 1做与运算，得到数组下标，hash % (2^4)；本质就是和长度取余，等价计算方式：hash & (2^4 - 1)")]),a._v(" "),t("li",[a._v("把put进来的key，value封装成entry对象")]),a._v(" "),t("li",[a._v("判断数组下标对应的位置\n"),t("ul",[t("li",[a._v("若为空，则把entry存在该数组位置")]),a._v(" "),t("li",[a._v("若不为空，则把entry插入到链表中，并判断该链表中是否存在相同的key，如果存在，更新value")]),a._v(" "),t("li",[a._v("如果超过8个且数组长度大于64，则进行树化，变成红黑树。红黑树主要为了解决链表过长导致查询和插入效率低的问题，解决这个问题，也可以通过数组扩容，把链表缩短。所以在数组长度还不太长的时候，可以先通过数组扩容来解决。")]),a._v(" "),t("li",[a._v("入托红黑树节点个数<6转为链表")])])])]),a._v(" "),t("h3",{attrs:{id:"扩容流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩容流程"}},[a._v("#")]),a._v(" 扩容流程")]),a._v(" "),t("ul",[t("li",[a._v("HashMap的扩容指的是数组的扩容，因为数组占用的是连续的内存空间，所以数组的扩容其实只能新开一个新的数组，然后把老数组上的元素转移到新的数组上来，这样才是数组的扩容")]),a._v(" "),t("li",[a._v("当HashMap中的元素数量超过阈值（阈值threshold = 当前容量capacity * 负载因子loadfactor）")]),a._v(" "),t("li",[a._v("先创建一个2倍数大小的数组")]),a._v(" "),t("li",[a._v("然后遍历老数组上的每一个位置，如果这个位置上是一个链表，就把这个链表上的元素转移到新数组上去")]),a._v(" "),t("li",[a._v("在这个过程中就需要遍历链表，JDK7和JDK8的扩容方式是不一样的，JDK7简单的遍历链表上的每一个元素，然后按每个元素的hashcode结合新数组的长度重新计算得出一个下标，而重新得到的这个数组下标很可能和之前的下标是不一样的，这样子就达到扩容之后某个链表会变短，达到扩容目的，缩短链表长度，提高查询效率。在JDK8中，因为设计红黑树，其会用到一个双向链表来维护红黑树的元素，会遍历该位置的双向链表，统计哪些元素在扩容之后还在原位置，哪些元素在扩容之后在新位置，这样遍历完双向链表后，就会得到两个子链表，一个放在原下标位置，一个放在新下标位置，如果原下标位置或新下标位置没有元素，则红黑树不用拆分，否则判断这两个子链表长度，如果超过8个，则进行树化，否则直接将原位置的子链表转移到新位置。")]),a._v(" "),t("li",[a._v("元素转移完之后，把新数组对象赋值给HashMap的table属性，老数组会被回收。")])]),a._v(" "),t("h2",{attrs:{id:"concurrenthashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),t("h3",{attrs:{id:"数据结构-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-2"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),t("h4",{attrs:{id:"jdk1-7-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-7-2"}},[a._v("#")]),a._v(" JDK1.7")]),a._v(" "),t("ul",[t("li",[a._v("数组+链表")]),a._v(" "),t("li",[a._v("segment分段锁\n"),t("ul",[t("li",[a._v("继承ReentrantLock")]),a._v(" "),t("li",[a._v("尝试获取锁存在竞争就自旋，阻塞")])])]),a._v(" "),t("li",[a._v("get方法使用volatile修饰，不加锁，保证高效")]),a._v(" "),t("li",[a._v("HashEntry")])]),a._v(" "),t("h4",{attrs:{id:"jdk1-8-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8-2"}},[a._v("#")]),a._v(" JDK1.8")]),a._v(" "),t("ul",[t("li",[a._v("数组+链表+红黑树")]),a._v(" "),t("li",[a._v("CAS+synchronized\n"),t("ul",[t("li",[a._v("CAS失败自旋保证成功")]),a._v(" "),t("li",[a._v("再失败就sync保证")])])]),a._v(" "),t("li",[a._v("Node")])]),a._v(" "),t("h2",{attrs:{id:"hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[a._v("#")]),a._v(" HashTable")]),a._v(" "),t("p",[a._v("在每个public方法上加synchronized，保证线程安全，所有操作都是串行的，效率低下")]),a._v(" "),t("h2",{attrs:{id:"arraylist-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-list"}},[a._v("#")]),a._v(" ArrayList(List)")]),a._v(" "),t("h3",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),t("ul",[t("li",[a._v("元素有放入顺序，元素可重复。")])]),a._v(" "),t("h3",{attrs:{id:"储存结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#储存结构"}},[a._v("#")]),a._v(" 储存结构")]),a._v(" "),t("ul",[t("li",[a._v("底层采用数组(连续的存储单元)来实现")])]),a._v(" "),t("h2",{attrs:{id:"copyonwritearraylist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist"}},[a._v("#")]),a._v(" CopyOnWriteArrayList")]),a._v(" "),t("ul",[t("li",[a._v("线程安全的类")]),a._v(" "),t("li",[a._v("采用一种读写分离的并发策略，读操作是无锁的，性能较高。写操作，将当前数组复制一份，在新的数组上进行修改，然后替换原数组。")])]),a._v(" "),t("h2",{attrs:{id:"linkedlist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),t("ul",[t("li",[a._v("双向链表")]),a._v(" "),t("li",[a._v("适合插入删除频繁的情况，内部维护了链表的长度")])]),a._v(" "),t("h2",{attrs:{id:"linkedlistmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlistmap"}},[a._v("#")]),a._v(" LinkedListMap")]),a._v(" "),t("ul",[t("li",[a._v("怎么实现有序\n"),t("ul",[t("li",[a._v("内部维护了一个双向链表，有头尾节点，同时LinkedHashMap节点内部Entry内部除了继承HashMap的Node属性，还有before和after用于标识前置节点和后置节点")])])])]),a._v(" "),t("h2",{attrs:{id:"treemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),t("ul",[t("li",[a._v("通过key的比较器决定元素的顺序")]),a._v(" "),t("li",[a._v("底层是红黑树")])])])}),[],!1,null,null,null);t.default=r.exports}}]);