---
title: 多线程-线程基础
date: 2024-05-23 16:57:19
permalink: /java/thread-base/
categories:
  - Java基础
  - 多线程
tags:
  - 
author: 
  name: qouson
  link: https://github.com/qouson
---
# 多线程-线程基础

## 线程状态

![20210328213808](https://cdn.jsdelivr.net/gh/qouson/my-pic-bed/pic/20210328213808.png)

- 1.New：尚未启动的线程的线程状态。
- 2.Runnable：可运行线程的线程状态，等待CPU调度。
- 3.Blocked：线程阻塞等待监视器锁定的线程状态。处于synchronized同步代码块或方法中被阻塞。
- 4.Waiting：等待线程的线程状态。下列不带超时的方式：
  - Object.wait、Thread.join、LockSupport.park
- 5.Timed Waiting：具有指定等待时间的等待线程的线程状态。下列带超时的方式：
  - Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil
- 6.Terminated：终止线程的线程状态。线程正常完成执行或者出现异常。

## 线程中止

- 正确的中止
  - thread.interrupt()
    - 如果目标线程在调用Object class的wait()、wait(long)或wait(long,int)方法、join()、join(long,int)或sleep(long,int)方法时被阻塞，那么Interrupt会生效，该线程的中断状态将被清除，抛出InterruptedException异常。
    - 如果目标线程是被I/O或者NIO中的Channel所阻塞，同样，I/O操作会被中断或者返回特殊异常值。达到终止线程的目的。
    - 如果以上条件都不满足，则会设置此线程的中断状态。
  - flag标志位
    - 在线程中设置一个标志，当不符合的时候跳出程序。
- 不正确的中止
  - thread.~~stop()~~
    - 中止线程，并且清除监控器锁的信息，但是有可能导致线程安全问题，不建议使用
  - thread.~~destory()~~
    - jdk未实现该方法。

## 内存屏障和CPU缓存

### cpu性能优化的手段----缓存

- 为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。
- 例如：CPU高速缓存。尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存（cache）以提高性能。
- 多级缓存
  - L1Cache（一级缓存）是CPU第一层高速缓存，分为数据缓存和指令缓存。一般服务器CPU的L1缓存的容量通常在32-4096KB。
  - L2由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一高速存储器，即二级缓存。
  - L3现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。一般是多核共享一个L3缓存！
- 缓存同步协议
  - 多CPU读取同样的数据进行缓存，进行不同运算之后，最终写入主内存以哪个CPU为准？
  - 在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。
  - MESI协议，它规定每条缓存有个状态位，同时定义了下面四个状态：
  - 修改态（Modified）-此cache行已被修改过（脏行），内容已不同于主存，为此cache专有
  - 专有态（Exclusive）-此cache行内容同于主存，但不出现于其它cache中；
  - 共享态（Shared）-此cache行内容同于主存，但也出现于其它cache中；
  - 无效态（Invalid）-此cache行内容无效（空行）。
- 多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU。
- 也就是意味着，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证最终一致

### cpu性能优化的手段----运行时指令重排序

- 指令重排的场景：当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。
- 并非随便重排，需要遵守as-if-serial语义as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。
- 也就是说：编译器和处理器不会对存在数据依赖关系的操作做重排序。

### 两个问题

- 1、CPU高速缓存下有一个问题：
  - 缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步。在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。
- 2、CPU执行指令重排序优化下有一个问题：
  - 虽然遵守了as-if-serial语义，单仅在单CPU自己执行的情况下能保证结果正确。
  - 多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。

### 内存屏障

- 处理器提供了两个内存屏障指令（Memory Barrier）用于解决上述两个问题：
  - **写内存屏障（Store Memory Barrier）**：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。
  - **读内存屏障（Load Memory Barrier）**：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。

## 线程封闭

- 线程封闭的概念
  - 多线程访问共享可变数据时，涉及到线程间数据同步的问题。并不是所有时候，都要用到共享数据，所以线程封闭概念就提出来了。
  - 数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为线程封闭。
  - 线程封闭具体的体现有：**ThreadLocal、局部变量**
- **ThreadLocal**
  - **它是一个线程级别变量**，每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了，在并发模式下是绝对安全的变量。
  - 用法：ThreadLocal-T>var=new ThreadLocal-T>（）；会自动在每一个线程上创建一个T的副本，副本之间彼此独立，互不影响。
  - 可以用ThreadLocal存储一些参数，以便在线程中多个方法中使用，用来代替方法传参的做法。
  - **可以理解为，JVM维护了一个Map<Thread，T>，每个线程要用这个T的时候，用当前的线程去Map里面取。仅作为一个概念理解**
- 栈封闭
  - 局部变量的固有属性之一就是封闭在线程中。
  - 它们位于执行线程的栈中，其他线程无法访问这个栈。
